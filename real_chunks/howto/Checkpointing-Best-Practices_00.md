### Trick CheckPointing Best Practices > Other Resources You Might Find Useful

# Trick CheckPointing Best Practices

**Contents**

* [Prerequisite Knowledge](#prerequisite-knowledge)<br>
* [Do's and Don'ts](#guidelines)<br>
* [Other Resources You Might Find Useful](#other-resources)<br>

***

Part of the process of designing a Trick simulation model is to ensure that it can be reliably checkpointed. Trick provides a lot of support for checkpointing, but there are things to know, and pitfalls to avoid. The purpose of this article is to provide knowledge, and guidelines that will make checkpointing easier.

<a id=prerequisite-knowledge></a>
## Prerequisite Knowledge

The following is a high-level overview of the Trick Memory Manager and checkpointing. Understanding these concepts are important, and will help you design your sim models to be reliably checkpointable.

<a id=how-memory-allocations-are-recorded></a>
### How Memory Allocations are Recorded

The Memory Manager is the component that **"knows"** about the memory objects (allocations) in your Trick simulation. For each of these objects the Memory Manager stores the following **"knowledge"** :

1. **Name** - optional, but **STRONGLY** recommended.
2. **Address** - the address of the memory allocation.
3. **Storage-class** - this is either
 	* **TRICK\_LOCAL** for memory that is allocated by the Memory Manager, or
	* **TRICK\_EXTERN** for memory that is allocated outside the Memory Manager that the Memory Manager is "told" about.
4. **Data-type** is
	* Primitive type specifier (```TRICK_DOUBLE```, ```TRICK_INT```, ... etc.) , or
	* Composite type specifier (```TRICK_STRUCTURED```). In this case the details of the type are specified by an ```ATTRIBUTES``` structure that is generated by Trick's Interface Code Generator (ICG).

<a id=trick-object-serialization></a>
### Trick Object Serialization

The Memory Manager can convert (ie., serialize) any of the objects that it **"knows"** about to a portable, human-readable text representation, to the extent that it knows about them (ICG can only gather data-type knowledge from header files that it has scanned.) The object can later be re-created from this representation. The represention consists of:

1. A **definition** of the allocation, and
2. **value assignments** to each of the members of the allocations data type.

#### Example:

Suppose one were to perform the following allocation:

```double *dbl_p = (double*)TMM_declare_var_s("double dbl_array[3]");```

The Memory Manager would represent its **definition** as follows in a checkpoint :

```
double dbl_array[3];
```

If one were then to assign values to the object, i.e. :

```
